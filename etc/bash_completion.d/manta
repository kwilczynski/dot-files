# node-manta tools v5.1.1 completion
#   mchattr(1)
#   mchmod(1)
#   mfind(1)
#   mget(1)
#   minfo(1)
#   mjob(1)
#   mln(1)
#   mlogin(1)
#   mls(1)
#   mmd5(1)
#   mmkdir(1)
#   mmpu(1)
#   mput(1)
#   mrm(1)
#   mrmdir(1)
#   msign(1)
#   muntar(1)





function _mchattr_completer {

    # ---- cmd definition

    local cmd_shortopts="-H -a -h -i -k -u -v"
local cmd_longopts="--account --header --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --header=arrayOfString --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -k=string -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mchattr_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mchattr_completion {
        local _log_file=/dev/null
        [[ -z "$_mchattr_log" ]] || _log_file="$_mchattr_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mchattr_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mchattr_completion mchattr
elif type compdef &>/dev/null; then
    function _mchattr_completion {
        local _log_file=/dev/null
        [[ -z "$_mchattr_log" ]] || _log_file="$_mchattr_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mchattr_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mchattr_completion mchattr
elif type compctl &>/dev/null; then
    function _mchattr_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mchattr_log" ]] || _log_file="$_mchattr_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mchattr_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mchattr_completion mchattr
fi






function _mchmod_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -k -u -v"
local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mchmod_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mchmod_completion {
        local _log_file=/dev/null
        [[ -z "$_mchmod_log" ]] || _log_file="$_mchmod_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mchmod_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mchmod_completion mchmod
elif type compdef &>/dev/null; then
    function _mchmod_completion {
        local _log_file=/dev/null
        [[ -z "$_mchmod_log" ]] || _log_file="$_mchmod_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mchmod_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mchmod_completion mchmod
elif type compctl &>/dev/null; then
    function _mchmod_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mchmod_log" ]] || _log_file="$_mchmod_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mchmod_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mchmod_completion mchmod
fi






function _mfind_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -j -k -l -n -p -s -t -u -v"
local cmd_longopts="--account --help --insecure --json --keyId --limit --maxdepth --mindepth --name --parallel --role --size --subuser --type --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --limit=positiveInteger --maxdepth=positiveInteger --mindepth=positiveInteger --name=string --parallel=positiveInteger --role=arrayOfString --size=positiveInteger --subuser=string --type=string --url=string --user=string -a=string -k=string -l=positiveInteger -n=string -p=positiveInteger -s=positiveInteger -t=string -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mfind_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mfind_completion {
        local _log_file=/dev/null
        [[ -z "$_mfind_log" ]] || _log_file="$_mfind_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mfind_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mfind_completion mfind
elif type compdef &>/dev/null; then
    function _mfind_completion {
        local _log_file=/dev/null
        [[ -z "$_mfind_log" ]] || _log_file="$_mfind_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mfind_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mfind_completion mfind
elif type compctl &>/dev/null; then
    function _mfind_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mfind_log" ]] || _log_file="$_mfind_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mfind_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mfind_completion mfind
fi






function _mget_completer {

    # ---- cmd definition

    local cmd_shortopts="-H -O -a -h -i -k -o -q -u -v"
local cmd_longopts="--account --header --help --insecure --keyId --output --progress --quiet --remote-name --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --header=arrayOfString --keyId=string --output=string --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -k=string -o=string -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mget_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mget_completion {
        local _log_file=/dev/null
        [[ -z "$_mget_log" ]] || _log_file="$_mget_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mget_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mget_completion mget
elif type compdef &>/dev/null; then
    function _mget_completion {
        local _log_file=/dev/null
        [[ -z "$_mget_log" ]] || _log_file="$_mget_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mget_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mget_completion mget
elif type compctl &>/dev/null; then
    function _mget_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mget_log" ]] || _log_file="$_mget_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mget_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mget_completion mget
fi






function _minfo_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -k -u -v"
local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_minfo_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _minfo_completion {
        local _log_file=/dev/null
        [[ -z "$_minfo_log" ]] || _log_file="$_minfo_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _minfo_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _minfo_completion minfo
elif type compdef &>/dev/null; then
    function _minfo_completion {
        local _log_file=/dev/null
        [[ -z "$_minfo_log" ]] || _log_file="$_minfo_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _minfo_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _minfo_completion minfo
elif type compctl &>/dev/null; then
    function _minfo_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_minfo_log" ]] || _log_file="$_minfo_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _minfo_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _minfo_completion minfo
fi






function _mjob_completer {

    # ---- cmd definition

    local cmd_shortopts="-h"
local cmd_longopts="--help --version"
local cmd_optargs=""
local cmd_subcmds="addinputs cancel close cost create errors failures get help inputs list outputs share watch"
local cmd_allsubcmds="addinputs cancel close cost create errors failures get help inputs list outputs share watch"

local cmd__addinputs_shortopts="-a -b -h -i -k -o -p -u -v"
local cmd__addinputs_longopts="--account --batch --help --insecure --keyId --open --parallel --role --subuser --url --user --verbose --version"
local cmd__addinputs_optargs="--account=string --batch=positiveInteger --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -b=positiveInteger -k=string -p=positiveInteger -u=string"

local cmd__cancel_shortopts="-a -h -i -k -p -u -v"
local cmd__cancel_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__cancel_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"

local cmd__close_shortopts="-a -h -i -k -p -u -v"
local cmd__close_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__close_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"

local cmd__cost_shortopts="-a -h -i -k -n -p -q -u -v"
local cmd__cost_longopts="--account --help --insecure --keyId --name --parallel --quiet --role --subuser --url --user --verbose --version"
local cmd__cost_optargs="--account=string --keyId=string --name=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -n=string -p=positiveInteger -u=string"

local cmd__create_shortopts="-a -b -f -h -i -k -m -n -o -p -q -r -s -u -v -w"
local cmd__create_longopts="--account --asset --batch --cat-outputs --close --count --disk --dry-run --file --help --image --init --insecure --keyId --map --memory --name --open --parallel --quiet --reduce --role --subuser --url --user --verbose --version --watch"
local cmd__create_optargs="--account=string --asset=arrayOfString --batch=positiveInteger --count=positiveInteger --disk=positiveInteger --file=string --image=string --init=string --keyId=string --map=arrayOfString --memory=positiveInteger --name=string --parallel=positiveInteger --reduce=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -a=string -b=positiveInteger -f=string -k=string -m=arrayOfString -n=string -p=positiveInteger -r=arrayOfString -s=arrayOfString -u=string"

local cmd__errors_shortopts="-a -h -i -k -p -u -v"
local cmd__errors_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__errors_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"

local cmd__failures_shortopts="-a -h -i -k -p -u -v"
local cmd__failures_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__failures_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"

local cmd__get_shortopts="-a -h -i -k -p -u -v"
local cmd__get_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__get_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"

local cmd__help_shortopts=""
local cmd__help_longopts=""
local cmd__help_optargs=""

local cmd__inputs_shortopts="-a -h -i -k -p -u -v"
local cmd__inputs_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__inputs_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"

local cmd__list_shortopts="-a -h -i -k -l -n -s -u -v"
local cmd__list_longopts="--account --help --insecure --keyId --long --name --role --state --subuser --url --user --verbose --version"
local cmd__list_optargs="--account=string --keyId=string --name=string --role=arrayOfString --state=string --subuser=string --url=string --user=string -a=string -k=string -n=string -s=string -u=string"

local cmd__outputs_shortopts="-a -h -i -k -p -u -v"
local cmd__outputs_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__outputs_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"

local cmd__share_shortopts="-a -h -i -k -r -s -u -v"
local cmd__share_longopts="--account --help --insecure --keyId --readme --role --stdout --subuser --url --user --verbose --version"
local cmd__share_optargs="--account=string --keyId=string --readme=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -r=string -u=string"

local cmd__watch_shortopts="-a -h -i -k -p -u -v"
local cmd__watch_longopts="--account --help --insecure --keyId --parallel --role --subuser --url --user --verbose --version"
local cmd__watch_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mjob_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mjob_completion {
        local _log_file=/dev/null
        [[ -z "$_mjob_log" ]] || _log_file="$_mjob_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mjob_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mjob_completion mjob
elif type compdef &>/dev/null; then
    function _mjob_completion {
        local _log_file=/dev/null
        [[ -z "$_mjob_log" ]] || _log_file="$_mjob_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mjob_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mjob_completion mjob
elif type compctl &>/dev/null; then
    function _mjob_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mjob_log" ]] || _log_file="$_mjob_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mjob_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mjob_completion mjob
fi






function _mln_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -k -u -v"
local cmd_longopts="--account --help --insecure --keyId --role --role-tag --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
local cmd_argtypes="mpath mpath none"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mln_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mln_completion {
        local _log_file=/dev/null
        [[ -z "$_mln_log" ]] || _log_file="$_mln_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mln_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mln_completion mln
elif type compdef &>/dev/null; then
    function _mln_completion {
        local _log_file=/dev/null
        [[ -z "$_mln_log" ]] || _log_file="$_mln_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mln_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mln_completion mln
elif type compctl &>/dev/null; then
    function _mln_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mln_log" ]] || _log_file="$_mln_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mln_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mln_completion mln
fi






function _mlogin_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -c -e -h -i -k -q -s -u -v"
local cmd_longopts="--account --asset --command --disk --escape --help --image --init --insecure --keyId --memory --quiet --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --asset=arrayOfString --command=string --disk=positiveInteger --escape=string --image=string --init=string --keyId=string --memory=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -c=string -e=string -k=string -s=arrayOfString -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mlogin_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mlogin_completion {
        local _log_file=/dev/null
        [[ -z "$_mlogin_log" ]] || _log_file="$_mlogin_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mlogin_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mlogin_completion mlogin
elif type compdef &>/dev/null; then
    function _mlogin_completion {
        local _log_file=/dev/null
        [[ -z "$_mlogin_log" ]] || _log_file="$_mlogin_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mlogin_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mlogin_completion mlogin
elif type compctl &>/dev/null; then
    function _mlogin_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mlogin_log" ]] || _log_file="$_mlogin_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mlogin_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mlogin_completion mlogin
fi






function _mls_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -j -k -l -m -r -t -u -v"
local cmd_longopts="--account --fulljson --help --insecure --json --keyId --long --marker --reverse --role --subuser --time --type --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --marker=string --role=arrayOfString --subuser=string --type=string --url=string --user=string -a=string -k=string -m=string -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mls_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mls_completion {
        local _log_file=/dev/null
        [[ -z "$_mls_log" ]] || _log_file="$_mls_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mls_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mls_completion mls
elif type compdef &>/dev/null; then
    function _mls_completion {
        local _log_file=/dev/null
        [[ -z "$_mls_log" ]] || _log_file="$_mls_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mls_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mls_completion mls
elif type compctl &>/dev/null; then
    function _mls_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mls_log" ]] || _log_file="$_mls_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mls_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mls_completion mls
fi






function _mmd5_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -k -u -v"
local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mmd5_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mmd5_completion {
        local _log_file=/dev/null
        [[ -z "$_mmd5_log" ]] || _log_file="$_mmd5_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mmd5_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mmd5_completion mmd5
elif type compdef &>/dev/null; then
    function _mmd5_completion {
        local _log_file=/dev/null
        [[ -z "$_mmd5_log" ]] || _log_file="$_mmd5_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mmd5_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mmd5_completion mmd5
elif type compctl &>/dev/null; then
    function _mmd5_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mmd5_log" ]] || _log_file="$_mmd5_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mmd5_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mmd5_completion mmd5
fi






function _mmkdir_completer {

    # ---- cmd definition

    local cmd_shortopts="-H -a -h -i -k -p -u -v"
local cmd_longopts="--account --header --help --insecure --keyId --parents --role --role-tag --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --header=arrayOfString --keyId=string --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -k=string -u=string"
local cmd_argtypes="mdir"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mmkdir_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mmkdir_completion {
        local _log_file=/dev/null
        [[ -z "$_mmkdir_log" ]] || _log_file="$_mmkdir_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mmkdir_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mmkdir_completion mmkdir
elif type compdef &>/dev/null; then
    function _mmkdir_completion {
        local _log_file=/dev/null
        [[ -z "$_mmkdir_log" ]] || _log_file="$_mmkdir_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mmkdir_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mmkdir_completion mmkdir
elif type compctl &>/dev/null; then
    function _mmkdir_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mmkdir_log" ]] || _log_file="$_mmkdir_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mmkdir_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mmkdir_completion mmkdir
fi






function _mmpu_completer {

    # ---- cmd definition

    local cmd_shortopts="-h"
local cmd_longopts="--help --version"
local cmd_optargs=""
local cmd_subcmds="abort commit create get help list parts upload"
local cmd_allsubcmds="abort commit create get help list parts upload"

local cmd__abort_shortopts="-a -h -i -k -u -v"
local cmd__abort_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd__abort_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"

local cmd__commit_shortopts="-a -h -i -k -u -v"
local cmd__commit_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd__commit_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"

local cmd__create_shortopts="-H -a -c -h -i -k -m -s -u -v"
local cmd__create_longopts="--account --copies --header --help --insecure --keyId --md5 --role --size --subuser --url --user --verbose --version"
local cmd__create_optargs="--account=string --copies=positiveInteger --header=arrayOfString --keyId=string --md5=string --role=arrayOfString --size=positiveInteger --subuser=string --url=string --user=string -H=arrayOfString -a=string -c=positiveInteger -k=string -m=string -s=positiveInteger -u=string"

local cmd__get_shortopts="-a -h -i -k -u -v"
local cmd__get_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd__get_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"

local cmd__help_shortopts=""
local cmd__help_longopts=""
local cmd__help_optargs=""

local cmd__list_shortopts="-a -h -i -k -p -u -v"
local cmd__list_longopts="--account --help --includeParts --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd__list_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"

local cmd__parts_shortopts="-a -h -i -k -u -v"
local cmd__parts_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd__parts_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"

local cmd__upload_shortopts="-a -f -h -i -k -q -u -v"
local cmd__upload_longopts="--account --file --help --insecure --keyId --progress --quiet --role --subuser --url --user --verbose --version"
local cmd__upload_optargs="--account=string --file=file --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -f=file -k=string -u=string"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mmpu_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mmpu_completion {
        local _log_file=/dev/null
        [[ -z "$_mmpu_log" ]] || _log_file="$_mmpu_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mmpu_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mmpu_completion mmpu
elif type compdef &>/dev/null; then
    function _mmpu_completion {
        local _log_file=/dev/null
        [[ -z "$_mmpu_log" ]] || _log_file="$_mmpu_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mmpu_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mmpu_completion mmpu
elif type compctl &>/dev/null; then
    function _mmpu_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mmpu_log" ]] || _log_file="$_mmpu_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mmpu_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mmpu_completion mmpu
fi






function _mput_completer {

    # ---- cmd definition

    local cmd_shortopts="-H -a -c -f -h -i -k -m -p -q -u -v"
local cmd_longopts="--account --copies --file --header --help --insecure --keyId --md5 --parents --progress --quiet --role --role-tag --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --copies=positiveInteger --file=string --header=arrayOfString --keyId=string --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -c=positiveInteger -f=string -k=string -u=string"
local cmd_argtypes="mpath none"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mput_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mput_completion {
        local _log_file=/dev/null
        [[ -z "$_mput_log" ]] || _log_file="$_mput_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mput_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mput_completion mput
elif type compdef &>/dev/null; then
    function _mput_completion {
        local _log_file=/dev/null
        [[ -z "$_mput_log" ]] || _log_file="$_mput_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mput_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mput_completion mput
elif type compctl &>/dev/null; then
    function _mput_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mput_log" ]] || _log_file="$_mput_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mput_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mput_completion mput
fi






function _mrm_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -k -p -r -u -v"
local cmd_longopts="--account --help --insecure --keyId --parallel --recursive --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --parallel=positiveInteger --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -p=positiveInteger -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mrm_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mrm_completion {
        local _log_file=/dev/null
        [[ -z "$_mrm_log" ]] || _log_file="$_mrm_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mrm_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mrm_completion mrm
elif type compdef &>/dev/null; then
    function _mrm_completion {
        local _log_file=/dev/null
        [[ -z "$_mrm_log" ]] || _log_file="$_mrm_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mrm_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mrm_completion mrm
elif type compctl &>/dev/null; then
    function _mrm_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mrm_log" ]] || _log_file="$_mrm_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mrm_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mrm_completion mrm
fi






function _mrmdir_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -h -i -k -u -v"
local cmd_longopts="--account --help --insecure --keyId --role --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --keyId=string --role=arrayOfString --subuser=string --url=string --user=string -a=string -k=string -u=string"
local cmd_argtypes="mdir"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_mrmdir_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _mrmdir_completion {
        local _log_file=/dev/null
        [[ -z "$_mrmdir_log" ]] || _log_file="$_mrmdir_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _mrmdir_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _mrmdir_completion mrmdir
elif type compdef &>/dev/null; then
    function _mrmdir_completion {
        local _log_file=/dev/null
        [[ -z "$_mrmdir_log" ]] || _log_file="$_mrmdir_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _mrmdir_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _mrmdir_completion mrmdir
elif type compctl &>/dev/null; then
    function _mrmdir_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_mrmdir_log" ]] || _log_file="$_mrmdir_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _mrmdir_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _mrmdir_completion mrmdir
fi






function _msign_completer {

    # ---- cmd definition

    local cmd_shortopts="-a -e -f -g -h -i -k -m -u -v"
local cmd_longopts="--account --algorithm --expires --file --help --insecure --keyId --method --role --role-tag --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --algorithm=string --expires=positiveInteger --file=string --keyId=string --method=arrayOfString --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -a=string -e=positiveInteger -f=string -g=string -k=string -m=arrayOfString -u=string"
local cmd_argtypes="mpath"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_msign_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _msign_completion {
        local _log_file=/dev/null
        [[ -z "$_msign_log" ]] || _log_file="$_msign_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _msign_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _msign_completion msign
elif type compdef &>/dev/null; then
    function _msign_completion {
        local _log_file=/dev/null
        [[ -z "$_msign_log" ]] || _log_file="$_msign_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _msign_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _msign_completion msign
elif type compctl &>/dev/null; then
    function _msign_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_msign_log" ]] || _log_file="$_msign_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _msign_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _msign_completion msign
fi






function _muntar_completer {

    # ---- cmd definition

    local cmd_shortopts="-H -a -c -f -h -i -k -p -r -u -v"
local cmd_longopts="--account --copies --file --header --help --insecure --keyId --parallel --retries --role --role-tag --subuser --url --user --verbose --version"
local cmd_optargs="--account=string --copies=positiveInteger --file=string --header=arrayOfString --keyId=string --parallel=positiveInteger --retries=positiveInteger --role-tag=arrayOfString --role=arrayOfString --subuser=string --url=string --user=string -H=arrayOfString -a=string -c=positiveInteger -f=string -k=string -p=positiveInteger -r=positiveInteger -u=string"
local cmd_argtypes="mpath none"


    # ---- locals

    declare -a argv


    # ---- support functions

    function trace {
        [[ -n "$_muntar_log" ]] && echo "$*" >&2
    }

    function _dashdash_complete {
        local idx context
        idx=$1
        context=$2

        local shortopts longopts optargs subcmds allsubcmds argtypes
        shortopts="$(eval "echo \${cmd${context}_shortopts}")"
        longopts="$(eval "echo \${cmd${context}_longopts}")"
        optargs="$(eval "echo \${cmd${context}_optargs}")"
        subcmds="$(eval "echo \${cmd${context}_subcmds}")"
        allsubcmds="$(eval "echo \${cmd${context}_allsubcmds}")"
        IFS=', ' read -r -a argtypes <<< "$(eval "echo \${cmd${context}_argtypes}")"

        trace ""
        trace "_dashdash_complete(idx=$idx, context=$context)"
        trace "  shortopts: $shortopts"
        trace "  longopts: $longopts"
        trace "  optargs: $optargs"
        trace "  subcmds: $subcmds"
        trace "  allsubcmds: $allsubcmds"

        # Get 'state' of option parsing at this COMP_POINT.
        # Copying "dashdash.js#parse()" behaviour here.
        local state=
        local nargs=0
        local i=$idx
        local argtype
        local optname
        local prefix
        local word
        local dashdashseen=
        while [[ $i -lt $len && $i -le $COMP_CWORD ]]; do
            argtype=
            optname=
            prefix=
            word=

            arg=${argv[$i]}
            trace "  consider argv[$i]: '$arg'"

            if [[ "$arg" == "--" && $i -lt $COMP_CWORD ]]; then
                trace "    dashdash seen"
                dashdashseen=yes
                state=arg
                word=$arg
            elif [[ -z "$dashdashseen" && "${arg:0:2}" == "--" ]]; then
                arg=${arg:2}
                if [[ "$arg" == *"="* ]]; then
                    optname=${arg%=*}
                    val=${arg##*=}
                    trace "    long opt: optname='$optname' val='$val'"
                    state=arg
                    argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                    word=$val
                    prefix="--$optname="
                else
                    optname=$arg
                    val=
                    trace "    long opt: optname='$optname'"
                    state=longopt
                    word=--$optname

                    if [[ "$optargs" == *"-$optname="* && $i -lt $COMP_CWORD ]]; then
                        i=$(( $i + 1 ))
                        state=arg
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        word=${argv[$i]}
                        trace "    takes arg (consume argv[$i], word='$word')"
                    fi
                fi
            elif [[ -z "$dashdashseen" && "${arg:0:1}" == "-" ]]; then
                trace "    short opt group"
                state=shortopt
                word=$arg

                local j=1
                while [[ $j -lt ${#arg} ]]; do
                    optname=${arg:$j:1}
                    trace "    consider index $j: optname '$optname'"

                    if [[ "$optargs" == *"-$optname="* ]]; then
                        argtype=$(echo "$optargs" | awk -F "-$optname=" '{print $2}' | cut -d' ' -f1)
                        if [[ $(( $j + 1 )) -lt ${#arg} ]]; then
                            state=arg
                            word=${arg:$(( $j + 1 ))}
                            trace "      takes arg (rest of this arg, word='$word', argtype='$argtype')"
                        elif [[ $i -lt $COMP_CWORD ]]; then
                            state=arg
                            i=$(( $i + 1 ))
                            word=${argv[$i]}
                            trace "    takes arg (word='$word', argtype='$argtype')"
                        fi
                        break
                    fi

                    j=$(( $j + 1 ))
                done
            elif [[ $i -lt $COMP_CWORD && -n "$arg" ]] && $(echo "$allsubcmds" | grep -w "$arg" >/dev/null); then
                trace "    complete subcmd: recurse _dashdash_complete"
                _dashdash_complete $(( $i + 1 )) "${context}__${arg/-/_}"
                return
            else
                trace "    not an opt or a complete subcmd"
                state=arg
                word=$arg
                nargs=$(( $nargs + 1 ))
                if [[ ${#argtypes[@]} -gt 0 ]]; then
                    argtype="${argtypes[$(( $nargs - 1 ))]}"
                    if [[ -z "$argtype" ]]; then
                        # If we have more args than argtypes, we use the
                        # last type.
                        argtype="${argtypes[@]: -1:1}"
                    fi
                fi
            fi

            trace "    state=$state prefix='$prefix' word='$word'"
            i=$(( $i + 1 ))
        done

        trace "  parsed: state=$state optname='$optname' argtype='$argtype' prefix='$prefix' word='$word' dashdashseen=$dashdashseen"
        local compgen_opts=
        if [[ -n "$prefix" ]]; then
            compgen_opts="$compgen_opts -P $prefix"
        fi

        case $state in
        shortopt)
            compgen $compgen_opts -W "$shortopts $longopts" -- "$word"
            ;;
        longopt)
            compgen $compgen_opts -W "$longopts" -- "$word"
            ;;
        arg)
            # If we don't know what completion to do, then emit nothing. We
            # expect that we are running with:
            #       complete -o default ...
            # where "default" means: "Use Readline's default completion if
            # the compspec generates no matches." This gives us the good filename
            # completion, completion in subshells/backticks.
            #
            # We cannot support an argtype="directory" because
            #       compgen -S '/' -A directory -- "$word"
            # doesn't give a satisfying result. It doesn't stop at the trailing '/'
            # so you cannot descend into dirs.
            if [[ "${word:0:1}" == '$' ]]; then
                # By default, Bash will complete '$<TAB>' to all envvars. Apparently
                # 'complete -o default' does *not* give us that. The following
                # gets *close* to the same completions: '-A export' misses envvars
                # like "PS1".
                trace "  completing envvars"
                compgen $compgen_opts -P '$' -A export -- "${word:1}"
            elif [[ -z "$argtype" ]]; then
                # Only include opts in completions if $word is not empty.
                # This is to avoid completing the leading '-', which foils
                # using 'default' completion.
                if [[ -n "$dashdashseen" ]]; then
                    trace "  completing subcmds, if any (no argtype, dashdash seen)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                elif [[ -z "$word" ]]; then
                    trace "  completing subcmds, if any (no argtype, empty word)"
                    compgen $compgen_opts -W "$subcmds" -- "$word"
                else
                    trace "  completing opts & subcmds (no argtype)"
                    compgen $compgen_opts -W "$shortopts $longopts $subcmds" -- "$word"
                fi
            elif [[ $argtype == "none" ]]; then
                # We want *no* completions, i.e. some way to get the active
                # 'complete -o default' to not do filename completion.
                trace "  completing 'none' (hack to imply no completions)"
                echo "##-no-completion- -results-##"
            elif [[ $argtype == "file" ]]; then
                # 'complete -o default' gives the best filename completion, at least
                # on Mac.
                trace "  completing 'file' (let 'complete -o default' handle it)"
                echo ""
            elif ! type complete_$argtype 2>/dev/null >/dev/null; then
                trace "  completing '$argtype' (fallback to default b/c complete_$argtype is unknown)"
                echo ""
            else
                trace "  completing custom '$argtype'"
                completions=$(complete_$argtype "$word")
                if [[ -z "$completions" ]]; then
                    trace "  no custom '$argtype' completions"
                    # These are in ascii and "dictionary" order so they sort
                    # correctly.
                    echo "##-no-completion- -results-##"
                else
                    echo $completions
                fi
            fi
            ;;
        *)
            trace "  unknown state: $state"
            ;;
        esac
    }


    trace ""
    trace "-- $(date)"
    #trace "\$IFS: '$IFS'"
    #trace "\$@: '$@'"
    #trace "COMP_WORDBREAKS: '$COMP_WORDBREAKS'"
    trace "COMP_CWORD: '$COMP_CWORD'"
    trace "COMP_LINE: '$COMP_LINE'"
    trace "COMP_POINT: $COMP_POINT"

    # Guard against negative COMP_CWORD. This is a Bash bug at least on
    # Mac 10.10.4's bash. See
    # <https://lists.gnu.org/archive/html/bug-bash/2009-07/msg00125.html>.
    if [[ $COMP_CWORD -lt 0 ]]; then
        trace "abort on negative COMP_CWORD"
        exit 1;
    fi

    # I don't know how to do array manip on argv vars,
    # so copy over to argv array to work on them.
    shift   # the leading '--'
    i=0
    len=$#
    while [[ $# -gt 0 ]]; do
        argv[$i]=$1
        shift;
        i=$(( $i + 1 ))
    done
    trace "argv: '${argv[@]}'"
    trace "argv[COMP_CWORD-1]: '${argv[$(( $COMP_CWORD - 1 ))]}'"
    trace "argv[COMP_CWORD]: '${argv[$COMP_CWORD]}'"
    trace "argv len: '$len'"

    _dashdash_complete 1 ""
}



if type complete &>/dev/null; then
    function _muntar_completion {
        local _log_file=/dev/null
        [[ -z "$_muntar_log" ]] || _log_file="$_muntar_log"
        COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
            COMP_LINE="$COMP_LINE" \
            COMP_POINT="$COMP_POINT" \
            _muntar_completer -- "${COMP_WORDS[@]}" \
            2>$_log_file)) || return $?
    }
    complete -o default -F _muntar_completion muntar
elif type compdef &>/dev/null; then
    function _muntar_completion {
        local _log_file=/dev/null
        [[ -z "$_muntar_log" ]] || _log_file="$_muntar_log"
        compadd -- $(COMP_CWORD=$((CURRENT-1)) \
            COMP_LINE=$BUFFER \
            COMP_POINT=0 \
            _muntar_completer -- "${words[@]}" \
            2>$_log_file)
    }
    compdef _muntar_completion muntar
elif type compctl &>/dev/null; then
    function _muntar_completion {
        local cword line point words si
        read -Ac words
        read -cn cword
        let cword-=1
        read -l line
        read -ln point
        local _log_file=/dev/null
        [[ -z "$_muntar_log" ]] || _log_file="$_muntar_log"
        reply=($(COMP_CWORD="$cword" \
            COMP_LINE="$line" \
            COMP_POINT="$point" \
            _muntar_completer -- "${words[@]}" \
            2>$_log_file)) || return $?
    }
    compctl -K _muntar_completion muntar
fi


